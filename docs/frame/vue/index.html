<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>vue</title>
  </head>

  <body>
    <div id="app"></div>
    <script>
      const bucket = new WeakMap()
      const data = { foo: 1, bar: 2 }
      const obj = new Proxy(data, {
        get(target, key) {
          track(target, key)
          return target[key]
        },
        set(target, key, newVal) {
          target[key] = newVal
          trigger(target, key)
        },
      })

      function track(target, key) {
        if (!activeEffect) return
        let depsMap = bucket.get(target)
        if (!depsMap) {
          bucket.set(target, (depsMap = new Map()))
        }
        let deps = depsMap.get(key)
        if (!deps) {
          depsMap.set(key, (deps = new Set()))
        }
        deps.add(activeEffect)
        activeEffect.deps.push(deps)
      }

      function trigger(target, key) {
        const depsMap = bucket.get(target)
        if (!depsMap) return
        const effects = depsMap.get(key)
        //构造另外一个 Set集合并遍历
        const effectsToRun = new Set()
        // 如果 trigger 触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行
        effects &&
          effects.forEach((effectFn) => {
            if (effectFn !== activeEffect) {
              effectsToRun.add(effectFn)
            }
          })
        effectsToRun && effectsToRun.forEach((effectFn) => effectFn())
        return true
      }

      let activeEffect
      // effect 栈
      const effectStack = []
      function effect(fn) {
        const effectFn = () => {
          // 调用 cleanup 函数完成清除工作
          cleanup(effectFn)
          // 当 effectFn 执行时，将其设置为当前激活的副作用函数
          activeEffect = effectFn
          // 在调用副作用函数之前将当前副作用函数压入栈中
          effectStack.push(effectFn)
          fn()
          // 在当前副作用函数执行完毕后，将当前副作用函数弹出栈，并把activeEffect 还原为之前的值
          effectStack.pop()
          activeEffect = effectStack[effectStack.length - 1]
        }
        // activeEffect.deps 用来存储所有与该副作用函数相关联的依赖集合
        effectFn.deps = []
        // 执行副作用函数
        effectFn()
      }

      function cleanup(effectFn) {
        // 遍历 effectFn.deps 数组
        // 实际是引用，进行引用删除 将对应的依赖进行全部删除 text就不会进行触发遗留的副作用函数
        for (let i = 0; i < effectFn.deps.length; i++) {
          // deps 是依赖集合
          const deps = effectFn.deps[i]
          // 将 effectFn 从依赖集合中移除
          deps.delete(effectFn)
        }
        // 最后需要重置 effectFn.deps 数组
        effectFn.deps.length = 0
      }
      effect(() => {
        console.log(obj.foo)
      })
      obj.foo++
      console.log('结束了')
    </script>
  </body>
</html>
