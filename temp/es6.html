<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Document</title>
	</head>
	<body></body>
</html>

<script>
	const PENDING = 'pending'
	const FULFILLED = 'fulfilled'
	const REJECTED = 'rejected'

	function MyPromise(fn) {
		// 保存初始化状态
		var self = this

		// 初始化状态
		this.state = PENDING

		// 用于保存 resolve 或者 rejected 传入的值
		this.value = null

		// 用于保存 resolve 的回调函数
		this.onFulfilledCallbacks = []

		// 用于保存 reject 的回调函数
		this.onRejectedCallbacks = []

		// 状态转变为 resolved 方法
		function resolve(value) {
			// 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变
			if (value instanceof MyPromise) {
				return value.then(resolve, reject)
			}

			// 保证代码的执行顺序为本轮事件循环的末尾
			setTimeout(() => {
				// 只有状态为 pending 时才能转变，
				if (self.state === PENDING) {
					// 修改状态
					self.state = FULFILLED

					// 设置传入的值
					self.value = value

					// 执行回调函数
					self.onFulfilledCallbacks.forEach(callback => {
						callback(value)
					})
				}
			}, 0)
		}

		// 状态转变为 rejected 方法
		function reject(value) {
			// 保证代码的执行顺序为本轮事件循环的末尾
			setTimeout(() => {
				// 只有状态为 pending 时才能转变
				if (self.state === PENDING) {
					// 修改状态
					self.state = REJECTED

					// 设置传入的值
					self.value = value

					// 执行回调函数
					self.onRejectedCallbacks.forEach(callback => {
						callback(value)
					})
				}
			}, 0)
		}

		// 将两个方法传入函数执行
		try {
			fn(resolve, reject)
		} catch (e) {
			// 遇到错误时，捕获错误，执行 reject 函数
			reject(e)
		}
	}

	MyPromise.prototype.then = function (onFulfilled, onReject) {
		const self = this
		return new MyPromise((resolve, reject) => {
			let fulfilled = () => {
				try {
					const result = onFulfilled(self.value)
					return result instanceof MyPromise ? result.then(resolve, reject) : resolve(result)
				} catch (err) {
					reject(err)
				}
			}
			let rejected = () => {
				try {
					const result = onReject(self.value)
					return result instanceof MyPromise ? result.then(resolve, reject) : reject(result)
				} catch (err) {
					reject(err)
				}
			}
			switch (self.state) {
				case PENDING:
					self.onFulfilledCallbacks.push(fulfilled)
					self.onRejectedCallbacks.push(rejected)
					break
				case FULFILLED:
					fulfilled()
					break
				case REJECTED:
					rejected()
					break
			}
		})
	}

	MyPromise.race = function (args) {
		return new MyPromise((resolve, reject) => {
			for (let i = 0; i < args.length; i++) {
				args[i].then(resolve, reject)
			}
		})
	}

	MyPromise.all = function (promises) {
		return new MyPromise((resolve, reject) => {
			if (!Array.isArray(promises)) {
				throw new TypeError('arguments must be a array')
			}
			// 计算处理的promise实例数量
			let resolvedCounter = 0
			const promisesNum = promises.length
			// 保存每个promise的结果
			const resolvedResult = []
			for (let i = 0; i < promisesNum; i++) {
				// 使用Promise.resolve对返回的结果进行包装， 可以触发成功或者失败回调
				Promise.resolve(promises[i]).then(
					value => {
						resolvedCounter++
						resolvedResult[i] = value
						if (resolvedCounter === promisesNum) {
							return resolve(resolvedResult)
						}
					},
					error => {
						return reject(error)
					}
				)
			}
		})
	}

	let p1 = new MyPromise((resolve, reject) => {
		setTimeout(() => {
			resolve(1)
		}, 1000)
	})
	let p2 = new MyPromise((resolve, reject) => {
		setTimeout(() => {
			resolve(2)
		}, 2000)
	})
	let p3 = new MyPromise((resolve, reject) => {
		setTimeout(() => {
			resolve(3)
		}, 3000)
	})

	MyPromise.all([p3, p1, p2]).then(res => {
		console.log('打印***res', res)
	})
</script>
