(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{290:function(t,e,a){"use strict";a.r(e);var i=a(3),_=Object(i.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"面向对象三大特征"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#面向对象三大特征"}},[t._v("#")]),t._v(" 面向对象三大特征")]),t._v(" "),e("ol",[e("li",[t._v("继承")]),t._v(" "),e("li",[t._v("封装")]),t._v(" "),e("li",[t._v("多态")])]),t._v(" "),e("h2",{attrs:{id:"oop编程6大原则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#oop编程6大原则"}},[t._v("#")]),t._v(" OOP编程6大原则")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"center"}},[t._v("缩写")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("全称")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("中文")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("S")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("Single Responsibility Principle")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("单一职责原则")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("O")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("Open－Close Principle")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("开放封闭原则")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("L")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("Liskov Substitution Principle")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("里式替换原则")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("I")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("The Interface Segregation Principle")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("接口分离原则")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("D")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("The Dependency Inversion Principle")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("依赖倒置原则")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}}),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("Law of Demeter")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("迪米特法则-最少知识原则")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}}),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("Composite Reuse Principle")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("合成复用原则")])])])]),t._v(" "),e("h3",{attrs:{id:"_1-单一职责原则srp"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-单一职责原则srp"}},[t._v("#")]),t._v(" 1. 单一职责原则SRP")]),t._v(" "),e("ul",[e("li",[t._v("一个类或者一个模块只负责完成一个职责或者功能，不要设计大而全的类， 要设计粒度小，功能单一的类， 单一职责是为了实现代码高内聚，低耦合，提高代码的复用性，可读性，可维护性。")])]),t._v(" "),e("h3",{attrs:{id:"_2-开放封闭原则ocp"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-开放封闭原则ocp"}},[t._v("#")]),t._v(" 2. 开放封闭原则OCP")]),t._v(" "),e("ul",[e("li",[t._v("添加一个新功能，应该是通过现有共扩展代码（新增模块，类，方法，属性等）, 而非修改已有代码的方式来完成。")])]),t._v(" "),e("h3",{attrs:{id:"_3-里式替换原则lsp"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-里式替换原则lsp"}},[t._v("#")]),t._v(" 3. 里式替换原则LSP")]),t._v(" "),e("ul",[e("li",[t._v("所有引用基类的地方必须能透明的使用其子类的对象。 class A 和class B, a的类型上有b,那么所有用到b的地方都可以用a进行替换")])]),t._v(" "),e("h3",{attrs:{id:"_4-接口分离原则isp"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-接口分离原则isp"}},[t._v("#")]),t._v(" 4. 接口分离原则ISP")]),t._v(" "),e("ul",[e("li",[t._v("定义是：客户端不应该依赖它不需要的接口。另一种定义是：类间的依赖关系应该建立在最小的接口上。接口隔离原则将非常庞大，臃肿的接口拆分成更小的接口和更具体的接口，这样客户只需要知道他们感兴趣的方法。接口隔离原则的目的是系统解开耦合，从而容易重构、更改和重新部署。")])]),t._v(" "),e("h3",{attrs:{id:"_5-依赖倒置原则dip"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-依赖倒置原则dip"}},[t._v("#")]),t._v(" 5. 依赖倒置原则DIP")]),t._v(" "),e("ul",[e("li",[t._v("主要用来指导框架层面的设计。高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。")])]),t._v(" "),e("h3",{attrs:{id:"_6-迪米特法则-最少知识原则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-迪米特法则-最少知识原则"}},[t._v("#")]),t._v(" 6. 迪米特法则-最少知识原则")]),t._v(" "),e("ul",[e("li",[t._v("一个对象应该对其他对象有最少的了解。")])]),t._v(" "),e("h3",{attrs:{id:"_7-合成复用原则-composite-reuse-principle"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-合成复用原则-composite-reuse-principle"}},[t._v("#")]),t._v(" 7.合成复用原则（Composite Reuse Principle）")]),t._v(" "),e("ul",[e("li",[t._v("尽量首先使用合成/聚合的方式，而不是使用继承。")])])])}),[],!1,null,null,null);e.default=_.exports}}]);